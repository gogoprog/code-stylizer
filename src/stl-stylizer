#!/usr/bin/env python2

import argparse
import os
import json
import sys
import time
import traceback
import collections

from contextlib import contextmanager
from os.path import basename, dirname, isabs, isdir, join, realpath, relpath
from textwrap import dedent

import subprocess
import re

import clang.cindex
from clang.cindex import CompilationDatabase, CursorKind, Diagnostic, TranslationUnit, TypeKind, AccessSpecifier

class Tagger:
    def __init__(self):
        self.tags = {}
        self.current_file_name = None
        self.current_file_lines = None

    def tag(self, cursor, tagname):
        if self.current_file_name != realpath(cursor.location.file.name):
            self.current_file_name = realpath(cursor.location.file.name)
            debug("  opening " + self.current_file_name)
            with open(self.current_file_name) as f:
                self.current_file_lines = f.readlines()

        if self.current_file_name not in self.tags:
            self.tags[self.current_file_name] = set()

        return self.tags[self.current_file_name].add((
            self.current_file_lines[cursor.location.line - 1].rstrip(),
            tagname,
            cursor.location.line,
            cursor.location.offset))

class Entry:
    def __init__(self, name, cursor=None):
        self.children = []
        self.children_map = {}
        self.name = name
        self.cursor = cursor
        self.parent = None
        self.bases = []
    def has_child(self, name):
        return name in self.children_map
    def add_child(self, entry):
        self.children_map[entry.name] = entry
        self.children.append(entry)
        entry.parent = self
        return entry


def main(argv):
    global args
    global initialCwd

    args = parse_args(argv)
    initialCwd = os.getcwd()
    process_header("vector")
    #process_header("iostream")

def process_header(name):
    debug("  processing <" + name + "> header")
    tagger = Tagger()
    root_entry = Entry("root")
    file_name = "/tmp/stl-stylizer." + name + ".cpp"

    os.chdir(initialCwd)
    out = open(file_name, "wb")
    out.write("#include <" + name + ">\nint main(int argc, char *argv[]) { return EXIT_SUCCESS; }")
    out.close()

    do_tags([file_name], tagger, root_entry)

    os.chdir("..")
    if not os.path.exists("out"):
        os.makedirs("out")

    out = open("out/" + name + ".h", "wb")
    process_entry(out, root_entry)
    out.close()

    print("  generated out/" + name + ".h")

    os.chdir(initialCwd)

def do_tags(compiler_command_line, tagger, root_entry):
    index = clang.cindex.Index.create()

    try:
        start = time.time()
        tu = index.parse(None, compiler_command_line,
                         options=TranslationUnit.PARSE_SKIP_FUNCTION_BODIES)
        debug("  clang parse took %.2fs" % (time.time() - start))
    except Exception:
        debug(traceback.format_exc())
        error("Clang failed to parse '%s'" % " ".join(compiler_command_line))

    errors = [d for d in tu.diagnostics
              if d.severity in (Diagnostic.Error, Diagnostic.Fatal)]
    if len(errors) > 0:
        debug("\n".join([d.spelling for d in errors]))
        error("File '%s' failed clang's parsing and type-checking" %
              tu.spelling)

    start = time.time()
    for c in tu.cursor.get_children():
        do_cursor(c, tagger, root_entry)
    debug("  tag generation took %.2fs" % (time.time() - start))

def do_cursor(cursor, tagger, root_entry):
    global lastEntry
    if is_definition(cursor):
        parents = semantic_parents(cursor)
        direct_parent = root_entry

        for p in parents:
            if not direct_parent.has_child(p.displayname):
                direct_parent = direct_parent.add_child(Entry(p.displayname, p))
            else:
                direct_parent = direct_parent.children_map[p.displayname]

        name = cursor.displayname

        if not direct_parent.has_child(name):
            lastEntry = Entry(name, cursor)
            direct_parent.add_child(lastEntry)
        else:
            lastEntry = direct_parent.children_map[name]
            lastEntry.cursor = cursor

        tagger.tag(cursor, name)

    if should_tag_children(cursor):
        for c in cursor.get_children():
            do_cursor(c, tagger, root_entry)

    if cursor.kind == CursorKind.CXX_BASE_SPECIFIER:
        lastEntry.bases.append(cursor)

def is_definition(cursor):
    return (
        (cursor.is_definition() and not cursor.kind in [
            CursorKind.CXX_ACCESS_SPEC_DECL,
            CursorKind.TEMPLATE_TYPE_PARAMETER,
            CursorKind.UNEXPOSED_DECL,
            ]) or
        # work around bug (?) whereby using PARSE_SKIP_FUNCTION_BODIES earlier
        # causes libclang to report cursor.is_definition() as false for
        # function definitions.
        cursor.kind in [
            CursorKind.FUNCTION_DECL,
            CursorKind.CXX_METHOD,
            CursorKind.FUNCTION_TEMPLATE,
            ])

def semantic_parents(cursor):
    p = collections.deque()
    c = cursor.semantic_parent
    while c and is_named_scope(c):
        p.appendleft(c)
        c = c.semantic_parent
    return list(p)

def should_tag_children(cursor):
    return is_named_scope(cursor) or cursor.kind in [
        # 'extern "C" { ... }' should be LINKAGE_SPEC but is UNEXPOSED_DECL
        CursorKind.UNEXPOSED_DECL,
        ]

def is_named_scope(cursor):
    return cursor.kind in [
        CursorKind.NAMESPACE,
        CursorKind.STRUCT_DECL,
        CursorKind.UNION_DECL,
        CursorKind.ENUM_DECL,
        CursorKind.CLASS_DECL,
        CursorKind.CLASS_TEMPLATE,
        CursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,
        ]

def parse_args(argv):
    parser = argparse.ArgumentParser(
        description="Generate STL headers in different coding style.",
        usage="\nstl-stylizer [options] ")

    parser.add_argument("-v", "--verbose", action="store_true",
                        help="enable debugging output")
    parser.add_argument("--version", action="version",
                        version="stl-stylizer 0.1")

    a = parser.parse_args(argv[1:])

    return a

def debug(s):
    if args.verbose:
        sys.stderr.write(s + "\n")

def warn(s):
    sys.stderr.write("%s: Warning: %s\n" % (basename(sys.argv[0]), s))

def error(s):
    sys.stderr.write("%s: Error: %s\n" % (basename(sys.argv[0]), s))
    sys.exit(1)

def write_namespace(out, entry):
    out.write("namespace " + entry.name + " {\n")
    process_entry(out, entry)
    out.write("}\n")

def write_class(out, entry):
    if entry.name[0] == '_':
        return
    out.write("class " + snake_to_pascal_case(entry.name) + " : ")
    if len(entry.bases) > 0:
        if entry.bases[0].displayname[0] != "_":
            out.write("public " + snake_to_pascal_case(entry.bases[0].displayname) + ", ")

    out.write("public " + entry.name)

    out.write(" {\n")

    out.write("public:\n\tusing " + entry.name + "::" + entry.name + ";\n")
    process_entry(out, entry)
    out.write("}\n")

def write_method(out, entry):
    if entry.cursor.access_specifier == AccessSpecifier.PUBLIC:
        if entry.name[:8] != "operator":
            name = get_method_name(entry.name)
            named_args = get_method_named_args_def(entry.name)
            call_str = get_method_call(entry.name)
            has_result = (entry.cursor.result_type.kind != TypeKind.VOID)

            out.write("\t" + ("auto " if has_result else "void ") + snake_to_camel_case(entry.name) + named_args
                    + " {\n\t\t" + ("return " if has_result else "")  + call_str + ";\n\t}\n")


writers = {
    CursorKind.NAMESPACE.value: write_namespace,
    CursorKind.CLASS_DECL.value: write_class,
    CursorKind.CLASS_TEMPLATE_PARTIAL_SPECIALIZATION.value: write_class,
    CursorKind.CLASS_TEMPLATE.value: write_class,
    CursorKind.CXX_METHOD.value: write_method
}

def process_entry(out, entry):
    for child_entry in entry.children:
        if child_entry.cursor.kind.value in writers:
            writer = writers[child_entry.cursor.kind.value]
            writer(out, child_entry)

def get_method_name(displayname):
    return displayname[:displayname.index('(')]

def get_method_named_args_def(displayname):
    args = displayname[displayname.index('('):]

    if len(args) == 2:
        return args

    arg_index = 0
    index = 1
    previous_index = 1
    result = '('
    while index != -1:
        index = args.find(',', index)

        template_index = args.find('<', previous_index, index)

        if template_index != -1:
            index = args.find('>', template_index)
            index = args.find(',', index)

        if index == -1:
            break

        result += args[previous_index:index]
        result += " " + chr(ord('a') + arg_index) + ","
        index += 1
        previous_index = index
        arg_index += 1

    index = args.find(')', index)
    result += args[previous_index:index]
    result += " " + chr(ord('a') + arg_index) + ')'

    return result

def get_method_call(displayname):
    args = displayname[displayname.index('('):]

    if len(args) == 2:
        return displayname

    count = args.count(',') + 1

    result = get_method_name(displayname) + '('
    for i in range(0, count):
        result += chr(ord('a') + i)
        if i != count - 1:
            result += ', '
    result += ')'

    return result

def snake_to_camel_case(input):
    words = input.split('_')
    result = ""
    first = True
    for w in words:
        result += w[:1] if first else w[:1].upper()
        result += w[1:]
        first = False
    return result

def snake_to_pascal_case(input):
    words = input.split('_')
    result = ""
    for w in words:
        result += w[:1].upper()
        result += w[1:]
    return result

if __name__ == "__main__":
    sys.exit(main(sys.argv))
